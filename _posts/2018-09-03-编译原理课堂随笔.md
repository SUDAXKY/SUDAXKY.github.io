---
layout:     post   				   
title:      编译原理笔记 				
subtitle:   东南大学翟玉庆老师
date:       2018-09-03				
author:     Fortune					
header-img: img/post-bg-keybord.jpg 	
catalog: true 					
tags:								
    - 编译原理
---

## 18.09.3

### Classic 5 problems

1. ##### Enable?  -- Computability

   Computing: Transformation

   Truing Machine 理论计算模型：

   Initial state *(Automata 自动机)* End state

   ->实现

    冯诺伊曼：storing program

2. ##### Computing Complexity

   P-Problem 多项式时间问题

   NP-Problem 指数时间问题

   **Practical Enable**

3. ##### Data Object Description

   Data Structure + External Data Management

   External Data Management -> Data File: related data records

   DBMS: related Data Files

4. ##### HCI: Human Computer Interaction

5. ##### AI



### Framework of this course

Program -- Language:

​	1) Syntax: lexical/syntactical analyze 语法分析

​	2) Semantics 语义分析

​	3) Pragmatic 语用分析

​		A word may have multiple meanings--ambiguous

**Paring techniques** 

**Optimization**



### Introduction to compiling

1. Why avoid using machine lang in compiler and program?

   help to think at a level of abstraction

   facilitate robust code

2. Analysis-Synthesis Model of Compilation

   Core Data Strcture: **Syntax Tree / Parse Tree**

   Syntax Tree + Construction rule = Parse Tree

3. How to construct a compiler

   Self-Compiling -- **Interation(迭代的思想)**:

   ​	C Kernal: <Assign> <if> <goto>

   ​	C0 Compiler: Assembling language

   ​	C1 Compiler: C0 + <while>: C0

   Use compiler-construction tools: **Lex, Yacc**

   Port among different platforms -- **Transplanting**

## 18.09.10

### Chapter2 Language & Syntax Description

#### Section1 Alphabet & String

```c
/**
Compiler:

1. Analyse -- Correct
   1. legal -- syntax
   2. rational -- semantic
2. Transformation -- syntax-directed
3. Optimization

**/
```



**Complex System Description**

1. Blocking
2. Layering-- Hierarchical level

##### 1. Alphabet

None-empty set of symbol, usually expressed in 

sigma/V,

##### 2. Symbol

finest elements in a language

##### 3. String

Basic element

Finite sequence of symbols in a Alphabet

*Special String*: a String with 0 symbol --> Null String -->'\0'

##### 4. Sentence

complete element

A set of strings based on symbols in the Aplphabet in certain construction tules

--> A sequence of String

##### 5. Language

##### 6. Operations on sets of strings

General Combination Methods: Cartesion Product

**Closure / Positive Closure**

#### Section2 Grammer & Language

##### Concept

1. Grammar

   key word: 

   production: 产生式

   rule: relation - cause-effect\condition-effect\left-side -- > right-side

   formal(形式化)

2. None-terminal symbol  (VN)

   1. Support concept - Middle element(S/P/O)

3. Terminal symbol  (VT)

   1. Atomic Concept: Finest element

4. Start symbol  (S)

   1. Core concept - Topest element(Sentence)-->Start symbol

5. Production  (T)

   1. a set of rules to define the relations among strings



##### **How to decide a sentence's legality?**

6. Derivation(推导)

   From start symbol, using production forwardingly

   lazy(canonical) derivation:惰性推导 **LeftMost**/RightMost: 每次只使用一个产生式

   也可以使用parse tree

   Sentence Form(句型) 一种S的举例

   

   *Problem:*

   对同样一个None-Terminal Symbol eg. <Subject>

   1. Backtracing 回溯 -> 导致效率问题
   2. Full results 

   

7. Reduction(归约)

   From  instance, using the production backwordingly

   LestMost：从最左寻找可归约串(reduciable string-->right side of a production)

   *同样存在同一个右部对应多个左部的问题*

   

8. Sentential form, Sentence, Language

   

9. Recrusive definition of grammar rules

   1. Refinement

   2. Special case(限制递归的有限)

      

10. Meta-Language symbol 不作为语言本身的元符号 对应着 Actual symbol



##### Catalog of grammars

关注2-type 3-type

1-type -- context sensitive/length-added

2-type -- context free

3-type -- regular grammar，right-linear grammar

Question Type: write the language general expression



##### Formal defination

1. A grammar describes and only describes a core concept
2. Other VN & VT must be related to the Start Symbol
3. P->P is not allowed
4. A 属于 VN,  S 可以 推导到 aAb, A可以推导到c, c属于(VT)*