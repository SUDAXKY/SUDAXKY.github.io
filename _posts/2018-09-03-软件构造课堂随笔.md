---
layout:     post   				   
title:      软件构造笔记 				
subtitle:   南京大学冯桂焕、潘敏学
date:       2018-09-03				
author:     Fortune					
header-img: img/post-bg-map.jpg 	
catalog: true 					
tags:								
    - 软件构造
---

## 18.9.3

首要技术使命：管理复杂度

构造前期工作的目标（复查性工作）：降低风险

辨明软件项目的类型：
商业系统（高度迭代）

使命攸关

性命攸关（序列式）

## 18.9.12

**软件构造：编码、调试、一部分的详细设计和单元测试**

### 类设计的第一步：类的接口设计

#### 要对外展示一致的抽象层次

 	1. **一个类应该实现并仅实现是个ADT**
 	2. **当实现了多个ADT时，可以考虑重新组织类**
 	3. **抽象层次要到应用层次、到数据结构层次不够（不能混合）**
 	4. 理解类接口应该捕获的抽象到底是哪一个
 	5. 提供成对的服务：不要盲目创建相反操作（getter/setter）
 	6. 把不相关的信息转移到其他类
      	1. 思考子程序和数据之间的引用关系
 	7. 让接口可编程，而不是表达语义
      	1. 可编程部分：编译器可检查，接口数据类型、属性类型
      	2. 语义部分：编译器不可检查，接口怎样被使用
	8. 不要添加与接口抽象不一致的公用成员
	9. 同时考虑抽象性和内聚性

#### 好的封装，不要暴露自身数据结构和实现细节

1. 尽可能限制类和成员的可访问性
   1. 最严格的访问级别
   2. 保护接口抽象的完整性
2. 不要公开暴露成员数据
3. 不要对类的使用者做任何假设
4. no友元类
5. 不要因为一个子程序只使用公用子程序就把它纳入公开接口-始终保持抽象一致
6. 警惕从语义上破坏封装性

解决方案：针对接口编程

#### 留意过于紧密的耦合

1. 尽可能限制访问权限
2. 避免友元
3. 避免在公开的接口中暴露成员数据结构
4. 警觉迪米特法则

### Design&Implementation

#### 包含

面向对象设计的**主力技术**

实现has a 关系

警惕超过七个数据成员的类

#### 继承

表示一个类是另外一个类的特例

目的是写出更精简的代码

用public继承实现*是一个*的关系 — 基类对派生类将做什么设定了预期

对不可继承的类明确禁止

遵循里氏替换原则 — 基类中的所有子程序，用在他的派生类中拥有相同的语义，子类能够替换基类完成相同的语义，子类方法的前置条件更松，后置条件更严

只继承需要继承的部分 -- 如果仅使用实现而不是接口则考虑使用包含

不要覆盖不可覆盖的成员函数

把公用的内容大发哦继承🌲尽可能高的地方

以下情况值得怀疑：

	只有一个实例的类，**只有一个派生类的基类（不要为未来做设计）**

	覆盖了基类的子程序却什么都不做



## 18.9.17

#### 构造函数

尽可能在所有构造函数中初始化所有数据成员

优先采用深拷贝

单件属性的实现： private构造函数

#### 应该避免的类

万能类

无关紧要的类：只包含数据没有行为

用动词命名的类：只有行为没有数据