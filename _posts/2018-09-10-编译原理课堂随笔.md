---
layout:     post   				   
title:      编译原理笔记 				
subtitle:   东南大学翟玉庆老师
date:       2018-09-10				
author:     Fortune					
header-img: img/post-bg-keybord.jpg 	
catalog: true 					
tags:								
    - 编译原理
---

## 18.09.3

### Classic 5 problems

1. ##### Enable?  -- Computability

   Computing: Transformation

   Truing Machine 理论计算模型：

   Initial state *(Automata 自动机)* End state

   ->实现

    冯诺伊曼：storing program

2. ##### Computing Complexity

   P-Problem 多项式时间问题

   NP-Problem 指数时间问题

   **Practical Enable**

3. ##### Data Object Description

   Data Structure + External Data Management

   External Data Management -> Data File: related data records

   DBMS: related Data Files

4. ##### HCI: Human Computer Interaction

5. ##### AI



### Framework of this course

Program -- Language:

	1) Syntax: lexical/syntactical analyze 语法分析
	
	2) Semantics 语义分析
	
	3) Pragmatic 语用分析
	
		A word may have multiple meanings--ambiguous

**Paring techniques** 

**Optimization**



### Introduction to compiling

1. Why avoid using machine lang in compiler and program?

   help to think at a level of abstraction

   facilitate robust code

2. Analysis-Synthesis Model of Compilation

   Core Data Strcture: **Syntax Tree / Parse Tree**

   Syntax Tree + Construction rule = Parse Tree

3. How to construct a compiler

   Self-Compiling -- **Interation(迭代的思想)**:

   	C Kernal: <Assign> <if> <goto>
		
   	C0 Compiler: Assembling language
		
   	C1 Compiler: C0 + <while>: C0

   Use compiler-construction tools: **Lex, Yacc**

   Port among different platforms -- **Transplanting**

## 18.09.10

### Chapter2 Language & Syntax Description

#### Section1 Alphabet & String

```c
/**
Compiler:

1. Analyse -- Correct
   1. legal -- syntax
   2. rational -- semantic
2. Transformation -- syntax-directed
3. Optimization

**/
```



**Complex System Description**

1. Blocking
2. Layering-- Hierarchical level

##### 1. Alphabet

None-empty set of symbol, usually expressed in 

sigma/V,

##### 2. Symbol

finest elements in a language

##### 3. String

Basic element

Finite sequence of symbols in a Alphabet

*Special String*: a String with 0 symbol --> Null String -->'\0'

##### 4. Sentence

complete element

A set of strings based on symbols in the Aplphabet in certain construction tules

--> A sequence of String

##### 5. Language

##### 6. Operations on sets of strings

General Combination Methods: Cartesion Product

**Closure / Positive Closure**

#### Section2 Grammer & Language

##### Concept

1. Grammar

   key word: 

   production: 产生式

   rule: relation - cause-effect\condition-effect\left-side -- > right-side

   formal(形式化)

2. None-terminal symbol  (VN)

   1. Support concept - Middle element(S/P/O)

3. Terminal symbol  (VT)

   1. Atomic Concept: Finest element

4. Start symbol  (S)

   1. Core concept - Topest element(Sentence)-->Start symbol

5. Production  (P)

   1. a set of rules to define the relations among strings



##### **How to decide a sentence's legality?**

6. Derivation(推导)

   From start symbol, using production forwardingly

   lazy(canonical) derivation:惰性推导 **LeftMost**/RightMost: 每次只使用一个产生式

   也可以使用parse tree

   Sentence Form(句型) 一种S的举例



   *Problem:*

   对同样一个None-Terminal Symbol eg. <Subject>

   1. Backtracing 回溯 -> 导致效率问题
   2. Full results 

7. Reduction(归约)

   From  instance, using the production backwordingly

   LestMost：从最左寻找可归约串(reduciable string-->right side of a production)

   *同样存在同一个右部对应多个左部的问题*

8. Sentential form, Sentence, Language

9. Recrusive definition of grammar rules

   1. Refinement

   2. Special case(限制递归的有限)

10. Meta-Language symbol 不作为语言本身的元符号 对应着 Actual symbol



##### Catalog of grammars

关注2-type 3-type

0-type — 左部至少含有一个VN

1-type -- context sensitive/length-added

2-type -- context free (lexical construction rule)

3-type -- regular grammar，right-linear grammar(syntactic construction rule)

3-type - 2-type = embedded grammar

Question Type: write the language general expression



##### Formal defination

1. A grammar describes and only describes a core concept
2. Other VN & VT must be related to the Start Symbol
3. P->P is not allowed
4. A 属于 VN,  S 可以 推导到 aAb, A可以推导到c, c属于(VT)*



## 18.9.17

### Language -> Grammar(by experience)

#### Method1:  对称法

using embeded grammar

1. find out symmetrical axis -- special case
2. find out symmetrical properties



#### Method2: 逐步求精法（参数不相关或可拆解为不相关）

1. 自上而下
2. 从左向右



#### Method3：等价法

there are same peoperties in the two sides of a production



#### Method4:  电路状态转换法（处理奇偶性）

1. 构造转换图
   1. 决定状态 -> n个符号关心奇偶性，2^n个状态
   2. 连接状态 -> 相邻状态只能一位不同 边数(2^n) * (n+m)
2. 确定开始结束状态
   1. 全是0的状态作为结束状态
   2. 开始状态要根据题目要求来
3. 一条边一个产生式



#### Method5: 混合法.....

###  优化文法

1. 文法简化：删除无用的产生式
   1. P -> P
   2. useless VN(不顶天)
   3. VN要能推出VT(立地)
2. 删除空串产生式（为了提高效率）
   1. 找出所有的空串产生式
   2. 改写
   3. 删除（S -> 空串！！！ -> S' -> S|空串）

### 二义文法

同一个句子有两棵不同的分析树

## 18.10.08

### Chapter3 Lexical Analysis

#### Section 1 The role of the lexical analyzer

##### First phase of compiler

Source Program ->(                    )-> Token sequence ->(                        )-> Parser

Token(lexeme, Catalog, Inner Code)  

eg.('a123', ID, 1)

#### Section2 Specification of tokens

1. Regular definition of tokens
   1. defined in regular grammar(不够直观)
   2. defined in regular expression（单词模板）
2. The rule of regular expression over alphabet
   1. basic case: 
      1. 空
      2. a 属于 alphabet
   2. Combination:
      1. or |
      2. connect .
      3. closure *
   3. the Algebraic laws of regular expression



#### Section3 Recognition of tokens 

1. ##### Methods to recognition of tokens

   1. Automata with finite states

      FA:(S, s0, F, alphabet, map)

      F: end states sets

      map: 映射(一对一\多对一)  -> Function（DFA）

      FA: DFA/NFA

   2. Deterministic FA (DFA)

      五元组

      空边不合法

      Transition Table:  state0 * input -> state1

```java
while(1){
    ch = getchar();
    switch(state){
        case 0:
            if(ch = 'a')
            	state = 1;
            if(ch = 'b')
            	state = 1;
            /*
            ***
            ***
            */
        case 1:
            if(){
               state = 1; 
            }else{
               return;
            }     
    }
}
```

2. ##### NFA（为了闭包引入的）

   空边合法、一对多

3. ##### Language->RE->NFA -> DFA

   1. NFA -> DFA

      N case：空边 / 一对多（多对多）

      解决空边：空边closure

      解决一对多：子集构造法

      **表格驱动法**

      |    I    | a（边） | b（边） |
      | :-----: | :-----: | :-----: |
      | 1（I0） |  2(I1)  |  2(I2)  |
      |  I(1)   |         |         |
      |  (I2)   |         |         |

          1. 确定 I0 （初始状态）--> NFA初始状态为核的空边闭包
        2. 通过子集构造法构造后续状态（求I0的a(b)闭包），之后再求结果的空边闭包得到I1/I2
        3. 核相同，闭包也相同
        4. 确定Ii 与原来NFA的F（终态集合）的交集不为空，Ii就为DFA的F的元素

   2. 优化DFA

      1. 思想：等价类划分——>聚类/自上而下的分类
      2. 状态等价
         1. 强等价：后续节点相同
         2. **弱等价**：后续状态属于同一个当前节点的叶子结点集
      3. 优化过程
         1. 先根据是否属于F划分
         2. 再自上而下根据弱等价划分
         3. **因为深度优先，要记得最后回首掏**

   3. RE -> NFA

      1. 逐步求精
      2. Tompson Algorithm（自上而下组合）