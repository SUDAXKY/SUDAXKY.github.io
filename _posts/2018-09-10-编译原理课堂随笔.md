---
layout:     post   				   
title:      编译原理笔记 				
subtitle:   东南大学翟玉庆老师
date:       2018-09-10				
author:     Fortune					
header-img: img/post-bg-keybord.jpg 	
catalog: true 					
tags:								
    - 编译原理
---

## 18.09.3

### Classic 5 problems

1. ##### Enable?  -- Computability

   Computing: Transformation

   Truing Machine 理论计算模型：

   Initial state *(Automata 自动机)* End state

   ->实现

    冯诺伊曼：storing program

2. ##### Computing Complexity

   P-Problem 多项式时间问题

   NP-Problem 指数时间问题

   **Practical Enable**

3. ##### Data Object Description

   Data Structure + External Data Management

   External Data Management -> Data File: related data records

   DBMS: related Data Files

4. ##### HCI: Human Computer Interaction

5. ##### AI



### Framework of this course

Program -- Language:

	1) Syntax: lexical/syntactical analyze 语法分析
	
	2) Semantics 语义分析
	
	3) Pragmatic 语用分析
	
		A word may have multiple meanings--ambiguous

**Paring techniques** 

**Optimization**



### Introduction to compiling

1. Why avoid using machine lang in compiler and program?

   help to think at a level of abstraction

   facilitate robust code

2. Analysis-Synthesis Model of Compilation

   Core Data Strcture: **Syntax Tree / Parse Tree**

   Syntax Tree + Construction rule = Parse Tree

3. How to construct a compiler

   Self-Compiling -- **Interation(迭代的思想)**:

   	C Kernal: <Assign> <if> <goto>
		
   	C0 Compiler: Assembling language
		
   	C1 Compiler: C0 + <while>: C0

   Use compiler-construction tools: **Lex, Yacc**

   Port among different platforms -- **Transplanting**

## 18.09.10

### Chapter2 Language & Syntax Description

#### Section1 Alphabet & String

```c
/**
Compiler:

1. Analyse -- Correct
   1. legal -- syntax
   2. rational -- semantic
2. Transformation -- syntax-directed
3. Optimization

**/
```



**Complex System Description**

1. Blocking
2. Layering-- Hierarchical level

##### 1. Alphabet

None-empty set of symbol, usually expressed in 

sigma/V,

##### 2. Symbol

finest elements in a language

##### 3. String

Basic element

Finite sequence of symbols in a Alphabet

*Special String*: a String with 0 symbol --> Null String -->'\0'

##### 4. Sentence

complete element

A set of strings based on symbols in the Aplphabet in certain construction tules

--> A sequence of String

##### 5. Language

##### 6. Operations on sets of strings

General Combination Methods: Cartesion Product

**Closure / Positive Closure**

#### Section2 Grammer & Language

##### Concept

1. Grammar

   key word: 

   production: 产生式

   rule: relation - cause-effect\condition-effect\left-side -- > right-side

   formal(形式化)

2. None-terminal symbol  (VN)

   1. Support concept - Middle element(S/P/O)

3. Terminal symbol  (VT)

   1. Atomic Concept: Finest element

4. Start symbol  (S)

   1. Core concept - Topest element(Sentence)-->Start symbol

5. Production  (P)

   1. a set of rules to define the relations among strings



##### **How to decide a sentence's legality?**

6. Derivation(推导)

   From start symbol, using production forwardingly

   lazy(canonical) derivation:惰性推导 **LeftMost**/RightMost: 每次只使用一个产生式

   也可以使用parse tree

   Sentence Form(句型) 一种S的举例



   *Problem:*

   对同样一个None-Terminal Symbol eg. <Subject>

   1. Backtracing 回溯 -> 导致效率问题
   2. Full results 

7. Reduction(归约)

   From  instance, using the production backwordingly

   LestMost：从最左寻找可归约串(reduciable string-->right side of a production)

   *同样存在同一个右部对应多个左部的问题*

8. Sentential form, Sentence, Language

9. Recrusive definition of grammar rules

   1. Refinement

   2. Special case(限制递归的有限)

10. Meta-Language symbol 不作为语言本身的元符号 对应着 Actual symbol



##### Catalog of grammars

关注2-type 3-type

0-type — 左部至少含有一个VN

1-type -- context sensitive/length-added

2-type -- context free (lexical construction rule)

3-type -- regular grammar，right-linear grammar(syntactic construction rule)

3-type - 2-type = embedded grammar

Question Type: write the language general expression



##### Formal defination

1. A grammar describes and only describes a core concept
2. Other VN & VT must be related to the Start Symbol
3. P->P is not allowed
4. A 属于 VN,  S 可以 推导到 aAb, A可以推导到c, c属于(VT)*



## 18.9.17

### Language -> Grammar(by experience)

#### Method1:  对称法

using embeded grammar

1. find out symmetrical axis -- special case
2. find out symmetrical properties



#### Method2: 逐步求精法（参数不相关或可拆解为不相关）

1. 自上而下
2. 从左向右



#### Method3：等价法

there are same peoperties in the two sides of a production



#### Method4:  电路状态转换法（处理奇偶性）

1. 构造转换图
   1. 决定状态 -> n个符号关心奇偶性，2^n个状态
   2. 连接状态 -> 相邻状态只能一位不同 边数(2^n) * (n+m)
2. 确定开始结束状态
   1. 全是0的状态作为结束状态
   2. 开始状态要根据题目要求来
3. 一条边一个产生式



#### Method5: 混合法.....

###  优化文法

1. 文法简化：删除无用的产生式
   1. P -> P
   2. useless VN(不顶天)
   3. VN要能推出VT(立地)
2. 删除空串产生式（为了提高效率）
   1. 找出所有的空串产生式
   2. 改写
   3. 删除（S -> 空串！！！ -> S' -> S|空串）

### 二义文法

同一个句子有两棵不同的分析树

## 18.10.08

### Chapter3 Lexical Analysis

#### Section 1 The role of the lexical analyzer

##### First phase of compiler

Source Program ->(                    )-> Token sequence ->(                        )-> Parser

Token(lexeme, Catalog, Inner Code)  

eg.('a123', ID, 1)

#### Section2 Specification of tokens

1. Regular definition of tokens
   1. defined in regular grammar(不够直观)
   2. defined in regular expression（单词模板）
2. The rule of regular expression over alphabet
   1. basic case: 
      1. 空
      2. a 属于 alphabet
   2. Combination:
      1. or |
      2. connect .
      3. closure *
   3. the Algebraic laws of regular expression



#### Section3 Recognition of tokens 

1. ##### Methods to recognition of tokens

   1. Automata with finite states

      FA:(S, s0, F, alphabet, map)

      F: end states sets

      map: 映射(一对一\多对一)  -> Function（DFA）

      FA: DFA/NFA

   2. Deterministic FA (DFA)

      五元组

      空边不合法

      Transition Table:  state0 * input -> state1

```java
while(1){
    ch = getchar();
    switch(state){
        case 0:
            if(ch = 'a')
            	state = 1;
            if(ch = 'b')
            	state = 1;
            /*
            ***
            ***
            */
        case 1:
            if(){
               state = 1; 
            }else{
               return;
            }     
    }
}
```

2. ##### NFA（为了闭包引入的）

   空边合法、一对多

3. ##### Language->RE->NFA -> DFA

   1. NFA -> DFA

      N case：空边 / 一对多（多对多）

      解决空边：空边closure

      解决一对多：子集构造法

      **表格驱动法**

      |    I    | a（边） | b（边） |
      | :-----: | :-----: | :-----: |
      | 1（I0） |  2(I1)  |  2(I2)  |
      |  I(1)   |         |         |
      |  (I2)   |         |         |

          1. 确定 I0 （初始状态）--> NFA初始状态为核的空边闭包
        2. 通过子集构造法构造后续状态（求I0的a(b)闭包），之后再求结果的空边闭包得到I1/I2
        3. 核相同，闭包也相同
        4. 确定Ii 与原来NFA的F（终态集合）的交集不为空，Ii就为DFA的F的元素

   2. 优化DFA

      1. 思想：等价类划分——>聚类/自上而下的分类
      2. 状态等价
         1. 强等价：后续节点相同
         2. **弱等价**：后续状态属于同一个当前节点的叶子结点集
      3. 优化过程
         1. 先根据是否属于F划分
         2. 再自上而下根据弱等价划分
         3. **因为深度优先，要记得最后回首掏**

   3. RE -> NFA

      1. 逐步求精
      2. Tompson Algorithm（自上而下组合）





## 18.10.29

### Chapter4 Syntax Analyse

#### 自上而下的递归下降分析法

对于一个Grammar，一个VT对应一个子程序

eg.

```java
/*
S->aA|bB
A->cD|d
B->eB|f
D->g
*/

int S(){
    ch = getChar();
    if(ch == 'a'){
        return A();
    }else if(ch == 'b'){
        return B();
    }else{
        return 0;//表示结束
    }
}
//换一种文法
S->aA|aB
A->Ad|d
B->Be|e

//这种情况会出现回溯和栈溢出
//所以文法不能出现公共左子表达式和左递归
```

#### 预测分析法

##### PreProcess

###### 提取最大           公共左子表达式

当不清楚两个A为左部的产生式如何选择时，我们可以通过改写产生式来推后这个决定。

eg.

```java
//A->ab1|ab2     //最大公共左子表达式为a

//A->aA'
//A'->b1|b2
```



###### 消除左递归

目的：将左递归变成右递归形式

左递归：

 	1. 直接左递归：A->Aa|b
 	2. 间接左递归：A->Ba|b, B->Ab|e



消除直接左递归/消除间接左递归

![消除左递归](https://raw.githubusercontent.com/NJUSSJ/NJUSSJ.github.io/master/post_image/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92.png)

#### 预测分析程序的构造

#### 判断是否为合法表达式

使用如下结构

![预测分析](https://raw.githubusercontent.com/NJUSSJ/NJUSSJ.github.io/master/post_image/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E7%9A%84%E5%88%A4%E6%96%AD%E8%BF%87%E7%A8%8B.png)

#### 构造PPT（Predict Parsing Table）

##### First

![First](https://raw.githubusercontent.com/NJUSSJ/NJUSSJ.github.io/master/post_image/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/First.png)

##### Follow 



​								![Follow](https://raw.githubusercontent.com/NJUSSJ/NJUSSJ.github.io/master/post_image/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/Follow.png) 



**对于正常产生式的First填PPT**

**对于空串产生式：E'->null, Follow(E') = {&R, )}, 将E'->null填入[E', $R] 和 [E', )]**

#### 



#### LL(1)文法

第一个L：从左向右扫描

第二个L：最左推导

1: 读写头一次读一个字符

有没有LL（2）？

有。但是复杂度更高

有没有LL（0）？

理论上存在。但是没有意义

##### LL1的约束

1. 不能有公共左因子
2. 不能有左递归
3. 不能时二义文法







#### LR文法--通用语法分析法（基于规约、FA）

##### 状态命名

LR项：

1. 层的信息—用相应的产生式表示
2. 顺序—用点表示

其中点在最后的LR项叫可规约项，反之叫移进LR项（shift LR item）

eg.

![LR](https://raw.githubusercontent.com/NJUSSJ/NJUSSJ.github.io/master/post_image/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LR.png)

##### 状态的拓展（NFA-DFA）

类似Chapter3

![I0](https://raw.githubusercontent.com/NJUSSJ/NJUSSJ.github.io/master/post_image/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LR%E7%8A%B6%E6%80%81%E6%8B%93%E5%B1%95.jpg)

![DFA](https://raw.githubusercontent.com/NJUSSJ/NJUSSJ.github.io/master/post_image/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LR_FA.jpg)



![Translation Table](https://raw.githubusercontent.com/NJUSSJ/NJUSSJ.github.io/master/post_image/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LR%E8%BD%AC%E6%8D%A2Table.jpg)



关于转换表的解释

首先，Action填上全部的终结符，另外要添加一个$，然后GOTO填上所有的非终结符。

GOTO表的填写只需要在转换图的边上找到非终结符填写到对应的位置就好。

填写Si同理

对于ri，只需要找到各个状态中的可规约LR项，找到其对应的规约式填入